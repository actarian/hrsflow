{"version":3,"names":[],"mappings":"","sources":["src/app/app.js"],"sourcesContent":["/* jshint esversion: 6 */\n/* global window, document, Swiper, TweenMax, TimelineMax */\n\nimport Dom from './shared/dom';\nimport Follower from './shared/follower';\nimport Rect from './shared/rect';\nimport Triangles from './shared/triangles';\nimport Utils from './shared/utils';\nimport Video from './shared/video';\n\nexport default class App {\n\n\tconstructor() {}\n\n\tinit() {\n\t\tconst body = document.querySelector('body');\n\t\tconst page = document.querySelector('.page');\n\t\tDom.detect(body);\n\t\tconst swiperHero = new Swiper('.swiper-container--home-hero', {\n\t\t\tloop: true,\n\t\t\t// effect: 'fade',\n\t\t\t// followFinger: true,\n\t\t\tparallax: true,\n\t\t\tspaceBetween: 0,\n\t\t\tspeed: 600,\n\t\t\tautoplay: {\n\t\t\t\tdelay: 5000,\n\t\t\t\tdisableOnInteraction: true,\n\t\t\t},\n\t\t\ton: {\n\t\t\t\tinit: function() {\n\t\t\t\t\tthis.el.classList.add('ready');\n\t\t\t\t},\n\t\t\t\tslideChangeTransitionEnd: function() {\n\t\t\t\t\t// console.log('slideChange', this.slides.length, this.activeIndex);\n\t\t\t\t\tconst slide = this.slides[this.activeIndex];\n\t\t\t\t\tif (slide) {\n\t\t\t\t\t\tconst video = slide.querySelector('video');\n\t\t\t\t\t\tif (video) {\n\t\t\t\t\t\t\t// video.play();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\t/*\n\t\t\tpagination: {\n\t\t\t\tel: '.swiper-pagination',\n\t\t\t\tclickable: true,\n\t\t\t\tdynamicBullets: true,\n\t\t\t},\n\t\t\t*/\n\t\t});\n\t\tconst swiperHilights = new Swiper('.swiper-container--hilights', {\n\t\t\tloop: false,\n\t\t\t/*\n\t\t\tmousewheel: {\n\t\t\t\tinvert: true,\n\t\t\t},\n\t\t\t*/\n\t\t\tparallax: true,\n\t\t\tspaceBetween: 300,\n\t\t\tspeed: 600,\n\t\t\tpagination: {\n\t\t\t\tel: '.swiper-pagination',\n\t\t\t\tclickable: true,\n\t\t\t\tdynamicBullets: true,\n\t\t\t},\n\t\t\ton: {\n\t\t\t\tinit: function() {\n\t\t\t\t\tthis.el.classList.add('ready');\n\t\t\t\t},\n\t\t\t}\n\t\t});\n\t\tconst swiperGallery = new Swiper('.swiper-container--gallery', {\n\t\t\tloop: false,\n\t\t\tslidesPerView: 'auto',\n\t\t\tspaceBetween: 45,\n\t\t\tspeed: 600,\n\t\t\tpagination: {\n\t\t\t\tel: '.swiper-pagination',\n\t\t\t\tclickable: true,\n\t\t\t\tdynamicBullets: true,\n\t\t\t},\n\t\t\ton: {\n\t\t\t\tinit: function() {\n\t\t\t\t\tthis.el.classList.add('ready');\n\t\t\t\t},\n\t\t\t}\n\t\t});\n\t\tconst swipers = [swiperHero, swiperHilights, swiperGallery].filter(swiper => swiper.el !== undefined);\n\t\tconst videos = [].slice.call(document.querySelectorAll('video[playsinline]')).map((node, i) => {\n\t\t\tconst video = new Video(node);\n\t\t\tvideo.i = i;\n\t\t\treturn video;\n\t\t});\n\t\tconst triangles = [].slice.call(document.querySelectorAll('.triangles')).map((node, i) => {\n\t\t\tconst triangles = new Triangles(node);\n\t\t\ttriangles.i = i;\n\t\t\treturn triangles;\n\t\t});\n\t\tconst parallaxes = [].slice.call(document.querySelectorAll('[data-parallax]'));\n\t\tconst shadows = [].slice.call(document.querySelectorAll('[data-shadow]'));\n\t\tconst appears = [].slice.call(document.querySelectorAll('[data-appear]'));\n\t\tconst follower = new Follower(document.querySelector('.follower'));\n\t\tconst hrefs = [].slice.call(document.querySelectorAll('[href=\"#\"]'));\n\t\tconst links = [].slice.call(document.querySelectorAll('.btn, .nav:not(.nav--service)>li>a'));\n\t\tconst togglers = [].slice.call(document.querySelectorAll('[toggle]'));\n\t\tconst mouse = { x: 0, y: 0 };\n\t\tconst timeline = new TimelineMax();\n\t\tif (follower.enabled) {\n\t\t\tbody.classList.add('follower-enabled');\n\t\t}\n\t\tthis.body = body;\n\t\tthis.page = page;\n\t\tthis.swiperHero = swiperHero;\n\t\tthis.swiperHilights = swiperHilights;\n\t\tthis.swipers = swipers;\n\t\tthis.videos = videos;\n\t\tthis.triangles = triangles;\n\t\tthis.parallaxes = parallaxes;\n\t\tthis.shadows = shadows;\n\t\tthis.appears = appears;\n\t\tthis.follower = follower;\n\t\tthis.hrefs = hrefs;\n\t\tthis.links = links;\n\t\tthis.togglers = togglers;\n\t\tthis.mouse = mouse;\n\t\tthis.timeline = timeline;\n\t\tthis.onResize();\n\t\tthis.addListeners();\n\t\tbody.classList.add('ready');\n\t}\n\n\taddListeners() {\n\n\t\twindow.addEventListener('resize', () => {\n\t\t\tapp.onResize();\n\t\t});\n\n\t\t/*\n\t\twindow.addEventListener('scroll', Utils.debounce(() => {\n\t\t\tapp.onScroll();\n\t\t}));\n\t\t*/\n\n\t\twindow.addEventListener('scroll', Utils.throttle(() => {\n\t\t\tapp.onScroll();\n\t\t}, 1000 / 25));\n\n\t\tdocument.addEventListener('mousemove', (e) => {\n\t\t\tapp.onMouseMove(e);\n\t\t});\n\n\t\t/*\n\t\t// intersection observer\n\t\tconst intersection = new IntersectionService();\n\t\tparallaxes.forEach((node, i) => intersection.observe(node, (entry, ei) => {\n\t\t\tlet pow = 1 + 0.1 * i;\n\t\t\tpow = (pow * entry.intersectionRatio);\n\t\t\tnode.pow = pow;\n\t\t}));\n\t\t*/\n\n\t\t// href=\"#\" noop\n\t\tthis.hrefs.forEach((node) => {\n\t\t\tnode.addEventListener('click', (e) => {\n\t\t\t\te.preventDefault();\n\t\t\t\te.stopPropagation();\n\t\t\t});\n\t\t});\n\n\t\tthis.togglers.forEach((node) => {\n\t\t\tnode.addEventListener('click', (e) => {\n\t\t\t\tlet target = node.getAttribute('toggle');\n\t\t\t\ttarget = target ? document.querySelector(target) : node;\n\t\t\t\tlet toggle = node.getAttribute('toggle-class') || 'active';\n\t\t\t\tif (target.classList.contains(toggle)) {\n\t\t\t\t\ttarget.classList.remove(toggle);\n\t\t\t\t} else {\n\t\t\t\t\ttarget.classList.add(toggle);\n\t\t\t\t}\n\t\t\t\te.preventDefault();\n\t\t\t\te.stopImmediatePropagation();\n\t\t\t});\n\t\t});\n\n\t}\n\n\tonMouseMove(e) {\n\t\tthis.mouse.x = e.clientX / window.innerWidth - 0.5;\n\t\tthis.mouse.y = e.clientY / window.innerHeight - 0.5;\n\t\tif (this.follower.enabled) {\n\t\t\tthis.follower.follow(this.links.map(x => Rect.fromNode(x)));\n\t\t\tthis.follower.move({\n\t\t\t\tx: e.clientX,\n\t\t\t\ty: e.clientY\n\t\t\t});\n\t\t}\n\t}\n\n\tonResize() {\n\t\tthis.windowRect = new Rect({\n\t\t\ttop: 0,\n\t\t\tleft: 0,\n\t\t\twidth: window.innerWidth,\n\t\t\theight: window.innerHeight,\n\t\t});\n\t\tthis.triangles.forEach((animation) => {\n\t\t\tanimation.resize();\n\t\t});\n\t\t// this.follower.follow(this.links.map(x => Rect.fromNode(x)));\n\t}\n\n\tonScroll() {\n\t\tconst scrollTop = Dom.scrollTop();\n\t\t// fastscroll mobile\n\t\tif (Dom.fastscroll) {\n\t\t\tconst newTop = Math.round(scrollTop * 10) / 10;\n\t\t\tif (this.page.previousTop !== newTop) {\n\t\t\t\tthis.page.previousTop = newTop;\n\t\t\t\tDom.scrolling = true;\n\t\t\t} else {\n\t\t\t\tDom.scrolling = false;\n\t\t\t}\n\t\t}\n\t\tif (scrollTop > 80) {\n\t\t\tthis.body.classList.add('fixed');\n\t\t} else {\n\t\t\tthis.body.classList.remove('fixed');\n\t\t}\n\t\tthis.appears = [].slice.call(document.querySelectorAll('[data-appear]'));\n\t\t// this.follower.follow(this.links.map(x => Rect.fromNode(x)));\n\t}\n\n\trender() {\n\n\t\t// smoothscroll desktop\n\t\t// if (!Dom.overscroll && !Dom.touch) {\n\t\tif (!Dom.fastscroll) {\n\t\t\tconst scrollTop = Dom.scrollTop();\n\t\t\tif (this.body.offsetHeight !== this.page.offsetHeight) {\n\t\t\t\tthis.body.setAttribute('style', `height: ${this.page.offsetHeight}px;`);\n\t\t\t\t/*\n\t\t\t\tTweenMax.set(this.body, {\n\t\t\t\t\theight: this.page.offsetHeight,\n\t\t\t\t});\n\t\t\t\t*/\n\t\t\t}\n\t\t\tlet newTop = this.page.previousTop || 0;\n\t\t\tnewTop += (scrollTop - newTop) / 3;\n\t\t\tnewTop = Math.round(newTop * 10) / 10;\n\t\t\tif (newTop && !Number.isNaN(newTop) && this.page.previousTop !== newTop) {\n\t\t\t\tthis.page.previousTop = newTop;\n\t\t\t\t// this.page.setAttribute('style', `top: ${-newTop}px;`);\n\t\t\t\tthis.page.setAttribute('style', `transform: translateY(${-newTop}px);`);\n\t\t\t\t/*\n\t\t\t\tTweenMax.set(this.page, {\n\t\t\t\t\ty: -newTop,\n\t\t\t\t});\n\t\t\t\t*/\n\t\t\t\tDom.scrolling = true;\n\t\t\t} else {\n\t\t\t\tDom.scrolling = false;\n\t\t\t}\n\t\t} else if (this.body.hasAttribute('style')) {\n\t\t\tthis.body.removeAttribute('style');\n\t\t}\n\n\t\tif (!Dom.scrolling) {\n\t\t\t// shadows\n\t\t\tthis.shadows.forEach((node) => {\n\t\t\t\tconst xy = node.xy || { x: 0, y: 0 };\n\t\t\t\tconst dx = this.mouse.x - xy.x;\n\t\t\t\tconst dy = this.mouse.y - xy.y;\n\t\t\t\txy.x += dx / 8;\n\t\t\t\txy.y += dy / 8;\n\t\t\t\tconst shadow = node.getAttribute('data-shadow') || 90;\n\t\t\t\tconst alpha = (0.2 + 0.3 * (Math.abs(xy.x) + Math.abs(xy.y)) / 2).toFixed(3);\n\t\t\t\tconst x = (xy.x * -100).toFixed(2);\n\t\t\t\tconst y = (xy.y * -50).toFixed(2);\n\t\t\t\tconst boxShadow = `${x}px ${y}px ${shadow}px -10px rgba(0, 0, 0, ${alpha})`;\n\t\t\t\t// if (node.boxShadow !== boxShadow) {\n\t\t\t\t// \tnode.boxShadow = boxShadow;\n\t\t\t\tnode.setAttribute('style', `box-shadow: ${boxShadow}`);\n\t\t\t\t/*\n\t\t\t\tTweenMax.set(node, {\n\t\t\t\t\tboxShadow: boxShadow,\n\t\t\t\t});\n\t\t\t\t*/\n\t\t\t\t// }\n\t\t\t\tnode.xy = xy;\n\t\t\t});\n\t\t}\n\n\t\t// swipers\n\t\tthis.swipers.forEach((swiper, i) => {\n\t\t\tif (swiper.params.autoplay.enabled && !swiper.params.autoplay.disableOnInteraction) {\n\t\t\t\tconst node = swiper.el;\n\t\t\t\tlet rect = Rect.fromNode(node);\n\t\t\t\tconst intersection = rect.intersection(this.windowRect);\n\t\t\t\tif (intersection.y > 0) {\n\t\t\t\t\tif (!swiper.autoplay.running) {\n\t\t\t\t\t\tswiper.autoplay.start();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (swiper.autoplay.running) {\n\t\t\t\t\t\tswiper.autoplay.stop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// videos\n\t\tthis.videos.forEach((video, i) => {\n\t\t\tconst node = video.node;\n\t\t\tlet rect = Rect.fromNode(node);\n\t\t\tconst intersection = rect.intersection(this.windowRect);\n\t\t\tif (intersection.y > 0) {\n\t\t\t\tvideo.appear();\n\t\t\t} else {\n\t\t\t\tvideo.disappear();\n\t\t\t}\n\t\t});\n\n\t\tif (!Dom.mobile) {\n\n\t\t\t// triangles\n\t\t\tthis.triangles.forEach((triangle, i) => {\n\t\t\t\tconst node = triangle.node;\n\t\t\t\tlet rect = Rect.fromNode(node);\n\t\t\t\tconst intersection = rect.intersection(this.windowRect);\n\t\t\t\tif (intersection.y > 0) {\n\t\t\t\t\ttriangle.appear();\n\t\t\t\t} else {\n\t\t\t\t\ttriangle.disappear();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// parallax\n\t\t\t/*\n\t\t\tthis.parallaxes.forEach((node, i) => {\n\t\t\t\tlet currentY = node.currentY || 0;\n\t\t\t\tlet rect = Rect.fromNode(node);\n\t\t\t\trect = new Rect({\n\t\t\t\t\ttop: rect.top - currentY,\n\t\t\t\t\tleft: rect.left,\n\t\t\t\t\twidth: rect.width,\n\t\t\t\t\theight: rect.height,\n\t\t\t\t});\n\t\t\t\tconst intersection = rect.intersection(this.windowRect);\n\t\t\t\tcurrentY = intersection.center.y * parseInt(node.getAttribute('data-parallax'));\n\t\t\t\tif (node.currentY !== currentY) {\n\t\t\t\t\tnode.currentY = currentY;\n\t\t\t\t\tTweenMax.set(node, {\n\t\t\t\t\t\ttransform: 'translateY(' + currentY + 'px)',\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t\t*/\n\t\t\tthis.parallaxes.forEach((node, i) => {\n\t\t\t\tconst parallax = node.parallax || (node.parallax = parseInt(node.getAttribute('data-parallax')) || 5);\n\t\t\t\tconst direction = i % 2 === 0 ? 1 : -1;\n\t\t\t\tlet currentY = node.currentY || 0;\n\t\t\t\tlet rect = Rect.fromNode(node);\n\t\t\t\trect = new Rect({\n\t\t\t\t\ttop: rect.top - currentY,\n\t\t\t\t\tleft: rect.left,\n\t\t\t\t\twidth: rect.width,\n\t\t\t\t\theight: rect.height,\n\t\t\t\t});\n\t\t\t\tconst intersection = rect.intersection(this.windowRect);\n\t\t\t\tif (intersection.y > 0) {\n\t\t\t\t\tconst y = Math.min(1, Math.max(-1, intersection.center.y));\n\t\t\t\t\tconst s = (100 + parallax * 2) / 100;\n\t\t\t\t\tcurrentY = (y * parallax * direction).toFixed(3);\n\t\t\t\t\tif (node.currentY !== currentY) {\n\t\t\t\t\t\tnode.currentY = currentY;\n\t\t\t\t\t\tif (node.parentNode.classList.contains('background')) {\n\t\t\t\t\t\t\tnode.setAttribute('style', `left: 50%; transform: translateX(-50%) translateY(${currentY}%) scale3d(${s},${s},1.0);`);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnode.setAttribute('style', `left: 50%; transform: translateX(-50%) translateY(${currentY}%);`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// follower\n\t\t\tif (this.follower.enabled) {\n\t\t\t\tthis.follower.render();\n\t\t\t}\n\n\t\t}\n\n\t\t// appears\n\t\tlet fi = 0;\n\t\tthis.appears.forEach((node, i) => {\n\t\t\tlet rect = Rect.fromNode(node);\n\t\t\tconst intersection = rect.intersection(this.windowRect);\n\t\t\tif (intersection.y > 0) {\n\t\t\t\tfi = fi || i;\n\t\t\t\t/*\n\t\t\t\tlet overlap = '-=0.3';\n\t\t\t\tif (!this.timeline.isActive()) {\n\t\t\t\t\toverlap = '+=0';\n\t\t\t\t}\n\t\t\t\tthis.timeline.to(node, 0.5, { autoAlpha: 1 }, overlap);\n\t\t\t\t*/\n\t\t\t\tif (!node.to) {\n\t\t\t\t\tnode.to = setTimeout(() => {\n\t\t\t\t\t\tnode.classList.add('appeared');\n\t\t\t\t\t}, 150 * (i - fi));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (node.classList.contains('appeared')) {\n\t\t\t\t\tnode.to = null;\n\t\t\t\t\tnode.classList.remove('appeared');\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t}\n\n\tloop() {\n\t\tthis.render();\n\t\tif (this.playing) {\n\t\t\twindow.requestAnimationFrame(() => {\n\t\t\t\tthis.loop();\n\t\t\t});\n\t\t}\n\t}\n\n\tplay() {\n\t\tthis.playing = true;\n\t\tthis.loop();\n\t}\n\n\tpause() {\n\t\tthis.playing = false;\n\t}\n\n}\n\nvar app = new App();\n\nwindow.onload = () => {\n\tapp.init();\n\tapp.play();\n};\n"],"file":"app.js"}